(defun rcompile (fn &optional flst rflst cflst)
  (assert (eq (car fn) 'defun))
  (let* ((name (cadr fn))
         (args (if (member name rflst) (append flst (caddr fn)) (caddr fn))))
    `(setq ,(cadr fn)
           '(lambda ,args ,@(rcompile-body (cdddr fn) flst rflst
                                           (member (cadr fn) cflst))))))

(defun rcompile-body (body flst rflst copy?)
  (mapcar #'(lambda (exp) (rcompile-exp exp flst rflst copy?)) body))

(defun maybe-copy (x copy?)
  (if copy?
      `(copy ,x)
      x))

(defun rcompile-exp (exp flst rflst copy?)
  (cond
    ((atom exp) exp)
    ((eq (car exp) 'quote) exp)
    ((eq (car exp) 'if)
     `(if ,(rcompile-exp (cadr exp) flst rflst nil)
          ,(rcompile-exp (caddr exp) flst rflst copy?)
          ,(rcompile-exp (cadddr exp) flst rflst copy?)))
    ((eq (car exp) 'lambda)
     `(lambda ,(cadr exp) ,@(rcompile-body (cddr exp) flst rflst copy?)))
    ((eq (car exp) 'setq)
     `(setq ,(cadr exp) ,(rcompile-exp (caddr exp) flst rflst copy?)))
    ((atom (car exp))
     `(,@(if (eq (car exp) 'funcall) nil (list (car exp)))
         ,@(if (member (car exp) rflst)
               (mapcar #'(lambda (x) (maybe-copy x copy?)) flst)
               nil)
         ,@(mapcar #'(lambda (arg)
                       (maybe-copy (rcompile-exp arg flst rflst nil) copy?))
                   (cdr exp))))
    (t (mapcar #'(lambda (exp) (rcompile-exp exp flst rflst copy?)) exp))))

(defun recursive? (exp flst)
  (if (atom exp)
      (member exp flst)
      (or (recursive? (car exp) flst)
          (recursive? (cdr exp) flst))))

(defun rcompile-file (path &optional cflst)
  (let* ((defs
          (with-open-file (s path)
            (loop for e = (read s nil nil) if e collect e until (null e))))
         (flst (mapcar #'(lambda (def)
                           (assert (eq (car def) 'defun))
                           (cadr def))
                       defs))
         (rflst (loop for def in defs if (recursive? (cddr def) flst)
                   collect (cadr def)))
         (compiled
          (loop for def in defs collect (rcompile def flst rflst cflst)))
         (*print-case* :downcase))
    (print `((lambda () ,@compiled
                     (reval ,@flst 'WRITE_EXP_HERE
                            '((car . (lambda(x) (car (car x))))
                              (cdr . (lambda(x) (cdr (car x))))
                              (cons . (lambda(x) (cons (car x) (cadr x))))
                              (eq . (lambda(x) (eq (car x) (cadr x))))
                              (atom . (lambda(x) (atom (car x))))
                              (numberp . (lambda(x) (numberp (car x))))
                              (symbolp . (lambda(x) (symbolp (car x))))
                              (+ . (lambda(x) (+ (car x) (cadr x))))
                              (- . (lambda(x) (- (car x) (cadr x))))
                              (* . (lambda(x) (* (car x) (cadr x))))
                              (/ . (lambda(x) (/ (car x) (cadr x))))
                              (mod . (lambda(x) (mod (car x) (cadr x)))))
                            nil))))
    nil))

(rcompile-file "eval.lisp" '(reval))
